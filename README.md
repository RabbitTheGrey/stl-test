### STL_TEST

## Описание

С учетом того, что сервис высоконагружен, для реализации был выбран паттерн CQRS, в дальнейшем запросы и команды можно будет разделить по репликациям. Делать репликации в рамках простенького тестового задания, с Вашего позволения, не буду :)

Прогрев кеша и фоновую очистку реализовал через cron-jobs
`./routes/console.php`

Так же за обновление кеша отвечает `./app/Observers/SlotObserver.php` - класс для отслеживания обновлений в таблице `slots`

UPD: Передумал насчет перепрогрева в обсервере, тк здесь идет смешивание операций чтения и записи, и при больших объемах данных операция
займет кучу времени, поэтому лучше пусть кеш прогревается фоном каждую минуту без оверлаппинга, то есть по готовности.

В `./routes/web.php` вы ничего интересного не увидите, поскольку уже давно существует php 8 - роуты объявляются в аннотациях контроллеров
`./app/Http/Controllers`

Вся логика сервиса находится в `./app/Queries` и `./app/Commands`

Сервисная прослойка `./app/Service/SlotServiceInterface.php` отвечает за кеш и идемпотентность

## Инструкция по развертыванию


#### Перед началом рекомендую завести алиас для выполнения команд внутри контейнера:

```
alias stl="sudo docker exec stl-fpm"
```

В корневой папке создайте файл `touch .env`

Скопируйте в него содержимое `.env.example`

Вся необходимая инфраструктура находится в папке `build`

Для удобства добавил скрипты `sh/rebuild` и `sh/restart` для уже собранного проекта

Выполните `sh/rebuild` из директории `build`, должны быть доступны порты: 88, 5432, 6379

Изменять ничего не нужно, в примере содержатся параметры подключения из docker-compose

Для включения фоновой очистки и прогрева кеша добавьте задачу в `crontab -e`

```
* * * * * docker exec stl-fpm php artisan schedule:run >> /dev/null 2>&1
```
---

Все зависимости и миграции применяются автоматически при сборке

Тестовые данные находятся в `database/seeders`

Для заполнения базы выполните `stl php artisan db:seed`

---

Для авторизации в сервисе может понадобиться JWT Secret

`stl php artisan jwt:secret`

Поместите JWT Secret в `.env` в переменную `JWT_SECRET` если это не произошло автоматически


### Начало работы

Для авторизации в приложении выполните GET запрос

```json
localhost:88/login [GET]

body:
{
    "email": "example@mail.ru",
    "password": "passw0rd!"
}

```

В ответе придет token авторизации для ВСЕХ остальных запросов, используйте его в авторизации `Bearer Token`

Токен хранится 1 час, после чего необходимо получить его заново или использовать

```
localhost:88/refresh [GET]
```

### Примеры запросов
Запрос:
```
localhost:88/slots/availability [GET]
```
Ответ:
```json
[
  {"slot_id": 1, "capacity": 10, "remaining": 6},
  {"slot_id": 2, "capacity": 5, "remaining": 0}
]
```

#### На остальные запросы api возвращает только ответы true/false, поскольку CQRS методы не подразумевают тело объекта в ответе

Запрос:
```
localhost:88/slots/1/hold [POST]

headers:
- Idempotency-Key   123 (любая строка)
```
Предполагается, что Idempotency-Key генерируется на клиентской стороне
Внутри системы он привязывается к id пользлвателя и хранится в redis в течение 5 минут (после чего запись переходит в статус "cancelled" и ключ теряет актуальность)

Запрос:
```
localhost:88/holds/1/confirm [POST]
```

Запрос:
```
localhost:88/holds/{id} [DELETE]
```